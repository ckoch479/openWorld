#include "npcController.h"

npcController::npcController(npcEntity* newNPC, PhysicsWorld* newWorld)
{
	this->NPC = newNPC;
	this->world = newWorld;
	addNpcToWorld();
}

npcController::~npcController()
{

}

void npcController::updateController(float dt, Level currentLevel)
{
	bool groundContact = false;
	//calculate new postions/orientations
	transform* npcTransform = NPC->getTransform();
	glm::vec3 newPosition = npcTransform->position;
	//glm::vec3 physWorldPos = playerTransform->position;

	//checking for ground collision and applying gravity (uses heightmap generated by level.h)
	float height = currentLevel.getHeightAtPosition(npcTransform->position);
	if (npcTransform->position.y > height)
	{
		npcTransform->position.y = newPosition.y - (60 * 9.8) * dt;
		//playerVelocity.y += -((playerMass * 9.8) * dt);
	}
	//downward velocity is zero if ground contact is made
	if (npcTransform->position.y <= height)
	{
		npcTransform->position.y = height;
		velocity.y = 0.0f;
		groundContact = true;
	}

	//change velocity if walking
	if (this->NPC->getNPCaction() == walkingForward)
	{
		glm::vec3 relativeFront = NPC->getRelativeTransform()->front;
		npcTransform->position = glm::vec3(newPosition.x, npcTransform->position.y, newPosition.z) + glm::vec3(relativeFront.x, 0, relativeFront.z) * (float)4.0 * dt;
	}

	this->world->setBodyPosition(this->physicsId, npcTransform->position);
	this->NPC->setNPCtransform(*npcTransform);
	NPC->calculateRelTransform();

}

void npcController::addNpcToWorld()
{
	this->physicsId = this->world->createCapsuleShape(this->NPC->getTransform()->position, glm::quat(1.0, 0.0, 0.0, 0.0f), 50, 0.7, 1.5, Kinematic);
	//this->world->changeColliderOrigin(this->physicsId, glm::vec3(0.0, 1.5, 0.0));
	this->world->lockBodyRotationAxis(this->physicsId, glm::vec3(1, 1, 1));
}

